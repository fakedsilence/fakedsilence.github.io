<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>unity02 | 白日梦大师</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="面向对象 Object Oriented·概述面向过程的程序 &#x3D; 算法 + 数据结构； 关心解决问题的步骤！ 面向对象：关心谁在做什么。 从设计角度讲：先有对象，再有类。 从编码角度讲：先有类，再有对象。 **类 class 脚本 抽象的概念 “类别”**。 对象 具体的实例 个体。 ·主要思想分而治之将一个大的需求分解为许多类，每个类处理一个独立的模块。 拆分好处：独立模块便于分工，每">
<meta property="og:type" content="article">
<meta property="og:title" content="unity02">
<meta property="og:url" content="https://fakedsilence.github.io/2022/11/06/unity02/index.html">
<meta property="og:site_name" content="白日梦大师">
<meta property="og:description" content="面向对象 Object Oriented·概述面向过程的程序 &#x3D; 算法 + 数据结构； 关心解决问题的步骤！ 面向对象：关心谁在做什么。 从设计角度讲：先有对象，再有类。 从编码角度讲：先有类，再有对象。 **类 class 脚本 抽象的概念 “类别”**。 对象 具体的实例 个体。 ·主要思想分而治之将一个大的需求分解为许多类，每个类处理一个独立的模块。 拆分好处：独立模块便于分工，每">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="e:\%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%9B%BE.png">
<meta property="article:published_time" content="2022-11-06T11:03:39.000Z">
<meta property="article:modified_time" content="2022-11-17T04:48:11.420Z">
<meta property="article:author" content="白日梦大师">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="e:\%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%9B%BE.png">
  
    <link rel="alternate" href="/atom.xml" title="白日梦大师" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">白日梦大师</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">这是副标题</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://fakedsilence.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-unity02" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/06/unity02/" class="article-date">
  <time class="dt-published" datetime="2022-11-06T11:03:39.000Z" itemprop="datePublished">2022-11-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      unity02
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="面向对象-Object-Oriented"><a href="#面向对象-Object-Oriented" class="headerlink" title="面向对象 Object Oriented"></a>面向对象 Object Oriented</h1><h2 id="·概述"><a href="#·概述" class="headerlink" title="·概述"></a>·概述</h2><p><strong>面向过程的程序 &#x3D; 算法 + 数据结构</strong>； <strong>关心解决问题的步骤</strong>！</p>
<p><strong>面向对象：关心谁在做什么。</strong></p>
<p><strong>从设计角度讲：先有对象，再有类。 从编码角度讲：先有类，再有对象。</strong></p>
<p>**类 class 脚本 抽象的概念 “类别”**。</p>
<p><strong>对象 具体的实例 个体</strong>。</p>
<h2 id="·主要思想"><a href="#·主要思想" class="headerlink" title="·主要思想"></a>·主要思想</h2><h3 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h3><p><strong>将一个大的需求分解为许多类，每个类处理一个独立的模块。</strong></p>
<p><strong>拆分好处：独立模块便于分工，每个模块便于复用，可拓展性强。</strong></p>
<h3 id="封装变化"><a href="#封装变化" class="headerlink" title="封装变化"></a>封装变化</h3><p><strong>变化的地方独立封装，避免影响其他模块。</strong></p>
<h3 id="高内聚"><a href="#高内聚" class="headerlink" title="高内聚"></a>高内聚</h3><p><strong>类中的各个方法都在完成一项任务(单一职责的类)</strong></p>
<p><strong>复杂的实现封装在内部，对外提供简单的调用。</strong></p>
<h3 id="低耦合"><a href="#低耦合" class="headerlink" title="低耦合"></a>低耦合</h3><p><strong>类与类的关联性依赖度要低(每个类独立)。</strong></p>
<p><strong>让一个模块的改变，尽少影响其他模块。</strong></p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p><strong>高复用性、高扩展性、高维护性、高移植性</strong></p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>1.数据角度讲，将一些基本数据类型复合成一个自定义类型。</strong></p>
<p><strong>2.方法角度讲，向类外提供功能，隐藏实现的细节。</strong></p>
<p><strong>3.设计角度讲，分而治之，高耦合低内聚，封装变化</strong>。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p><strong>1.松散耦合，降低了程序各部分之间的依赖性。</strong></p>
<p><strong>2.简化编程，使用者不必了解具体的实现细节，只需要调用对外提供的功能。</strong></p>
<p><strong>3.增强安全性，以特定的访问权限来使用类成员，保护成员不被意外修改。</strong></p>
<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p><strong>1.private:私有的，类成员默认级别，仅在类内部可见。</strong></p>
<p><strong>2.internal:内部的，类默认级别，仅在程序集内可见。</strong></p>
<p><strong>3.protected:受保护的，类内部与派生类中可见。</strong></p>
<p><strong>4.protected internal:意为 internal 或 protected;程序集内或者派生类中可见。</strong></p>
<p><strong>5.public:公有的，类内外都可见。</strong></p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p><strong>语法：</strong></p>
<p><strong>用abstract修饰类即为抽象类。</strong></p>
<p><strong>抽象类中可能包含抽象成员(方法，属性)。</strong></p>
<p><strong>抽象类不能创建对象。</strong></p>
<p><strong>语义：</strong></p>
<p><strong>表示一个概念的抽象(可以存储子类直接使用的成员)。</strong></p>
<p><strong>只表示做什么，拥有什么数据，但往往不表达具体做法。</strong></p>
<p><strong>适用性：</strong></p>
<p><strong>1.当有行为，但是不需要实现的时候。</strong></p>
<p><strong>2.当有一些行为，在做法上有多种可能时，但又不希望客户了解具体做法。</strong></p>
<p><strong>3.不希望类创建时。</strong></p>
<p><strong>抽象类和普通类区别：</strong></p>
<p><strong>相同：都可以有静态、实例成员(数据、方法、构造函数)。</strong></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><strong>重用现有类的功能，在此基础上进行扩展。</strong></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p><strong>1.复用代码的一种方式。</strong></p>
<p><strong>2.统一概念，以层次化的方式管理类。</strong></p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p><strong>耦合度高(父类改变，无需通知子类)。</strong></p>
<p><img src="E:\核心类图.png" alt="核心类图"></p>
<h3 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h3><p><strong>1.多个类具有相同的数据或行为。</strong></p>
<p><strong>2.多个类从概念上是一致的，且需要进行统一处理。</strong></p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p><strong>父类同一种动作或行为(父类型的引用调用同一方法)，在不同的子类上有不同的实现。</strong></p>
<p><strong>继承将相关概念的共性进行抽象，并提供了一种复用的方式；多态在共性的基础上，体现类型以及行为的个性化，即同一个行为有多个不同的实现。</strong></p>
<h3 id="实现手段"><a href="#实现手段" class="headerlink" title="实现手段"></a>实现手段</h3><p><strong>1.虚方法：父类型的引用 指向 子类的对象，调用虚方法，执行子类中的重写方法。</strong></p>
<p><strong>2.抽象方法：抽象类的引用 指向 实现类的对象，调用抽象方法，执行实现类中重写方法。</strong></p>
<p><strong>3.接口：接口的引用</strong></p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="抽象类与接口的选择策略"><a href="#抽象类与接口的选择策略" class="headerlink" title="抽象类与接口的选择策略"></a>抽象类与接口的选择策略</h3><p><strong>抽象类与子类之间关系：是一种</strong></p>
<p><strong>接口与实现类之间关系：能够做(功能)</strong></p>
<h3 id="接口的显式实现"><a href="#接口的显式实现" class="headerlink" title="接口的显式实现"></a>接口的显式实现</h3><p><strong>作用：</strong></p>
<p><strong>1.解决多接口实现时的二义性。</strong></p>
<p><strong>2.解决接口中的成员对实现类不适用的问题。</strong></p>
<h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p><strong>一组对外的行为规范，要求它的实现类必须遵循。</strong></p>
<p><strong>只关注行为，不关注数据，且不关注行为的实现，实现由实现类完成。</strong></p>
<h3 id="·Framework常用接口"><a href="#·Framework常用接口" class="headerlink" title="·Framework常用接口"></a>·Framework常用接口</h3><p><strong>IComparable 可比较，使类型支持比大小的功能。</strong></p>
<p><strong>IComparer 比较器，提供比较的方法，常用于排序比较。</strong></p>
<p><strong>IEnumerable可枚举，使类型支持简单迭代。</strong></p>
<p><strong>IEnumerator枚举器，支持MoveNext，自己可以控制迭代的节奏。</strong></p>
<h3 id="方法隐藏"><a href="#方法隐藏" class="headerlink" title="方法隐藏"></a>方法隐藏</h3><p><strong>定义：在子类中使用关键字修饰的与父类同签名的方法。</strong></p>
<p><strong>作用：通过子类引用调用时，覆盖继承而来但不适用的旧方法，执行子类的新方法。</strong></p>
<h3 id="隐藏原理"><a href="#隐藏原理" class="headerlink" title="隐藏原理"></a>隐藏原理</h3><p><strong>子类在方法表中增加一个新地址。</strong></p>
<p><strong>所以通过子类引用调用时使用新纪录，执行子类中新方法。</strong></p>
<p><strong>通过父类引用调用时使用旧记录，执行父类中方法。</strong></p>
<h2 id="Unity协同程序"><a href="#Unity协同程序" class="headerlink" title="Unity协同程序"></a>Unity协同程序</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p><strong>具有多个返回点(yield)，可以在特定时机分部执行的函数。</strong></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><strong>Unity每帧处理GameObject中的协同函数，直到函数执行完毕。</strong></p>
<h2 id="反射-ArrayHelper"><a href="#反射-ArrayHelper" class="headerlink" title="反射 ArrayHelper"></a>反射 ArrayHelper</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p><strong>动态获取类型信息，动态创建对象，动态访问成员的过程。</strong></p>
<h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p><strong>在编译时无法了解类型，在运行时获取类型信息，创建对象，访问成员。</strong></p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><strong>1.得到数据类型</strong></p>
<p><strong>2.动态创建对象</strong></p>
<p><strong>3.查看类型信息(了解本身信息，成员信息)</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fakedsilence.github.io/2022/11/06/unity02/" data-id="clik3zuy4000018u634rk7ds3" data-title="unity02" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2022/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%9501/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">数据结构与算法01</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/11/06/unity02/">unity02</a>
          </li>
        
          <li>
            <a href="/2022/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%9501/">数据结构与算法01</a>
          </li>
        
          <li>
            <a href="/2022/09/17/unity01/">unity01</a>
          </li>
        
          <li>
            <a href="/2022/09/17/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 白日梦大师<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>